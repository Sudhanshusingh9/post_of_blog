<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<style>
body {font-family: Arial;}

/* Style the tab */
.tab {
  overflow: hidden;
  border: 1px solid #ccc;
  background-color: #04f03f;
}

/* Style the buttons inside the tab */
.tab button {
  background-color: inherit;
  float: left;
  border: none;
  outline: none;
  cursor: pointer;
  padding: 14px 16px;
  transition: 0.3s;
  font-size: 17px;
}

/* Change background color of buttons on hover */
.tab button:hover {
  background-color: #ddd;
}

/* Create an active/current tablink class */
.tab button.active {
  background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
  display: none;
  padding: 6px 12px;
  border: 1px solid #ccc;
  border-top: none;
}
</style>
</head>
<body>
<div class="tab">
  <button class="tablinks" onclick="openCity(event, 'London')">Python</button>
  <button class="tablinks" onclick="openCity(event, 'Paris')">Java</button>
  <button class="tablinks" onclick="openCity(event, 'Tokyo')">C++</button>
</div>
<!--python start-->
<div id="London" class="tabcontent">
<pre><code class="python" style="font-size:15px;">  
    class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def backtrack(row, cols, diag1, diag2):
            if row == n:
                result.append(board[:])
                return
            for col in range(n):
                if col in cols or (row+col) in diag1 or (row-col) in diag2:
                    continue
                board[row][col] = 'Q'
                cols.add(col)
                diag1.add(row+col)
                diag2.add(row-col)
                backtrack(row+1, cols, diag1, diag2)
                board[row][col] = '.'
                cols.remove(col)
                diag1.remove(row+col)
                diag2.remove(row-col)

        board = [['.' for _ in range(n)] for _ in range(n)]
        result = []
        backtrack(0, set(), set(), set())
        return [[''.join(row) for row in solution] for solution in result]

      
</code></pre>

<p style="font-size:15px;">
    Explanation (Python):<br><br> 

    We define a class Solution.<br><br> 
    The solveNQueens method takes in an integer n representing the size of the chessboard and returns a list of solutions, where each solution is represented as a list of strings.<br><br> 
    We define a nested function backtrack that performs the backtracking algorithm.<br><br> 
    The backtrack function takes in the current row, sets representing the occupied columns (cols), and sets representing the occupied diagonals (diag1 and diag2).<br><br> 
    If the current row equals n, it means we have found a valid solution. We append a copy of the board to the result list.<br><br> 
    Otherwise, we iterate over each column in the current row.<br><br> 
    If the column is already occupied or any of the diagonals are occupied, we continue to the next column.<br><br> 
    Otherwise, we place a queen in the current cell by setting board[row][col] = 'Q', and add the column index to cols, the sum of row and column index to diag1, and the difference of row and column index to diag2.<br><br> 
    We then recursively call backtrack for the next row (row+1).<br><br> 
    After the recursive call, we backtrack by resetting the current cell to '.' and removing the column index from cols, the sum of row and column index from diag1, and the difference of row and column index from diag2.<br><br> 
    In the main function, we initialize the board as a 2D array of '.' characters.<br><br> 
    We initialize an empty result list to store the solutions.<br><br> 
    We call the backtrack function with initial parameters: row=0, cols=set(), diag1=set(), diag2=set().<br><br> 
    Finally, we convert each solution in result to a list of strings by joining the characters in each row, and return the resulting list of solutions.<br><br> 
  </p>
</div>
<!--python end-->


<!--java start-->
<div id="Paris" class="tabcontent">
<pre><code class="java" style="font-size:15px;">
    class Solution {
        public List<List<String>> solveNQueens(int n) {
            List<List<String>> result = new ArrayList<>();
            char[][] board = new char[n][n];
            for (int i = 0; i < n; i++) {
                Arrays.fill(board[i], '.');
            }
            backtrack(0, new HashSet<>(), new HashSet<>(), new HashSet<>(), board, result);
            return result;
        }
        
        private void backtrack(int row, Set<Integer> cols, Set<Integer> diag1, Set<Integer> diag2,
                               char[][] board, List<List<String>> result) {
            if (row == board.length) {
                List<String> solution = new ArrayList<>();
                for (char[] rowArr : board) {
                    solution.add(new String(rowArr));
                }
                result.add(solution);
                return;
            }
            for (int col = 0; col < board.length; col++) {
                if (cols.contains(col) || diag1.contains(row + col) || diag2.contains(row - col)) {
                    continue;
                }
                board[row][col] = 'Q';
                cols.add(col);
                diag1.add(row + col);
                diag2.add(row - col);
                backtrack(row + 1, cols, diag1, diag2, board, result);
                board[row][col] = '.';
                cols.remove(col);
                diag1.remove(row + col);
                diag2.remove(row - col);
            }
        }
    }
    
    
</code></pre>

<p style="font-size:15px;">
    Explanation (Java):<br><br> 

    We define a class Solution.<br><br> 
    The solveNQueens method takes in an integer n representing the size of the chessboard and returns a list of solutions, where each solution is represented as a list of strings.<br><br> 
    We create a 2D character array board of size nxn and fill it with '.' characters to represent empty cells.<br><br> 
    We initialize an empty result list to store the solutions.<br><br> 
    We call the backtrack method with initial parameters: row=0, cols=set(), diag1=set(), diag2=set(), board, and result.<br><br> 
    The backtrack method performs the backtracking algorithm to find all valid solutions.<br><br> 
    If the current row equals the size of the board, it means we have found a valid solution. We create a new solution list and add each row of the board as a string to the solution.<br><br> 
    We add the solution to the result.<br><br> 
    Otherwise, we iterate over each column in the current row.<br><br> 
    If the column is already occupied or any of the diagonals are occupied, we continue to the next column.<br><br> 
    Otherwise, we place a queen in the current cell by setting board[row][col] = 'Q', and add the column index to cols, the sum of row and column index to diag1, and the difference of row and column index to diag2.<br><br> 
    We then recursively call backtrack for the next row (row+1).<br><br> 
    After the recursive call, we backtrack by resetting the current cell to '.' and removing the column index from cols, the sum of row and column index from diag1, and the difference of row and column index from diag2<br><br> 
<p>
  
</div>
<!--java end-->

<!--c++ start-->  
<div id="Tokyo" class="tabcontent">
<pre><code class="cpp" style="font-size:15px;">    
    class Solution {
        public:
            vector<vector<string>> solveNQueens(int n) {
                vector<vector<string>> result;
                vector<string> board(n, string(n, '.'));
                backtrack(0, board, result);
                return result;
            }
            
        private:
            void backtrack(int row, vector<string>& board, vector<vector<string>>& result) {
                if (row == board.size()) {
                    result.push_back(board);
                    return;
                }
                for (int col = 0; col < board.size(); col++) {
                    if (!isSafe(row, col, board)) {
                        continue;
                    }
                    board[row][col] = 'Q';
                    backtrack(row + 1, board, result);
                    board[row][col] = '.';
                }
            }
            
            bool isSafe(int row, int col, vector<string>& board) {
                int n = board.size();
                for (int i = 0; i < row; i++) {
                    if (board[i][col] == 'Q') {
                        return false;
                    }
                }
                for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
                    if (board[i][j] == 'Q') {
                        return false;
                    }
                }
                for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
                    if (board[i][j] == 'Q') {
                        return false;
                    }
                }
                return true;
            }
        };
        
        
        
</code></pre>
<p style="font-size:15px;">
    Explanation (c++):<br><br> 

    We define a class Solution.<br><br> 
    The solveNQueens method takes in an integer n representing the size of the chessboard and returns a vector of solutions, where each solution is represented as a vector of strings.<br><br> 
    We create a 2D vector board of size nxn and initialize all cells to '.' to represent empty cells.<br><br> 
    We initialize an empty result vector to store the solutions.<br><br> 
    We call the backtrack method with initial parameters: row=0, board, and result.<br><br> 
    The backtrack method performs the backtracking algorithm to find all valid solutions.<br><br> 
    If the current row equals the size of the board, it means we have found a valid solution. We add a copy of the board to the result.<br><br> 
    Otherwise, we iterate over each column in the current row.<br><br> 
    If placing a queen in the current cell is not safe (conflicts with other queens), we continue to the next column.<br><br> 
    Otherwise, we place a queen in the current cell by setting board[row][col] = 'Q'.<br><br> 
    We then recursively call backtrack for the next row (row+1).<br><br> 
    After the recursive call, we backtrack by resetting the current cell to '.'.<br><br> 
    The isSafe function is used to check if placing a queen in a particular cell is safe (does not conflict with other queens).<br><br> 
    It checks if there is no queen in the same column, no queen in the same diagonal from top-left to bottom-right, and no queen in the same diagonal from top-right to bottom-left.<br><br> 
  
</p>
</div>
<!--c++ end-->>
  
<script>
function openCity(evt, cityName) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(cityName).style.display = "block";
  evt.currentTarget.className += " active";
}
  
// Show the first tab by default
document.getElementById("London").style.display = "block";
document.getElementsByClassName("tablinks")[0].className += " active";
</script>
   
</body>
</html>